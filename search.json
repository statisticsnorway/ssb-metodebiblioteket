[
  {
    "objectID": "rogpython.html",
    "href": "rogpython.html",
    "title": "Integrering av R og Python",
    "section": "",
    "text": "Mange av funksjonene i Metodebiblioteket er skrevet i R, mens de fleste i SSB utvikler produksjonsløpene sine i Python. På denne siden finner du tips til hvordan du kan bruke R-funksjoner fra Python - og motsatt.",
    "crumbs": [
      "Veiledning",
      "Integrering av R og Python"
    ]
  },
  {
    "objectID": "rogpython.html#sec-rwrapr",
    "href": "rogpython.html#sec-rwrapr",
    "title": "Integrering av R og Python",
    "section": "Bruk av RWrapR",
    "text": "Bruk av RWrapR\nPython-pakken RWrapR ble utviklet under Hack4SSB 2024. Den ligger på PyPI og er tilgjengelig for alle. Pakken gjør R-funksjoner tilgjengelige direkte i Python-miljøet. Dette kan være en god løsning når du kun ønsker å bruke én R-funksjon i et ellers Python-basert produksjonsløp.\nPakken er fortsatt under utvikling og mangler noe funksjonalitet, for eksempel håndtering av manglende data, så vær forsiktig og test godt. Pakken RWrapR kan installeres fra PYPI med:\npoetry add rwrapr\nSe videoen under og koden rwrapr_kjoring.py for eksempler.\n\n\n\n\n\nFor mer detaljer, se dokumentsidene for RWrapR.",
    "crumbs": [
      "Veiledning",
      "Integrering av R og Python"
    ]
  },
  {
    "objectID": "rogpython.html#sec-subprocess",
    "href": "rogpython.html#sec-subprocess",
    "title": "Integrering av R og Python",
    "section": "Kjøring av R-skriptfiler fra Python",
    "text": "Kjøring av R-skriptfiler fra Python\nSelvstendige R-skriptfiler kan kjøres fra Python ved hjelp av et kall til terminalen med Rscript. Med «selvstendige» menes programmer som kan kjøres uavhengig, uten avhengighet til andre systemer eller variabler som allerede ligger i minnet. Fordelen med denne metoden er at den benytter renv-miljøet og gi bedre kontroll over håndtering av datatyper, manglende verdier og lignende, ettersom dette kan verifiseres ved å kjøre programmet direkte i R.\nVi anbefaler å bruke subprocess i Python for å utføre kjøringen. For eksempel, for å kjøre et R-skript med navn lage_statistikk.R, kan følgende kode benyttes:\nimport subprocess\n\nsubprocess.run([\"Rscript\", \"lager_statistikk.R\"])\nSe videoen under og kode subprocess_kjoring.py for eksempler.",
    "crumbs": [
      "Veiledning",
      "Integrering av R og Python"
    ]
  },
  {
    "objectID": "rogpython.html#sec-reticulate",
    "href": "rogpython.html#sec-reticulate",
    "title": "Integrering av R og Python",
    "section": "Kjøring av Python-funksjoner i R med reticulate",
    "text": "Kjøring av Python-funksjoner i R med reticulate\nPython-funksjoner kan kjøres direkte fra R ved hjelp av pakken reticulate. Denne pakken gjør det mulig å integrere Python-kode i R-skript, og gir dermed en fleksibel løsning når R-produksjonsløp krever funksjonalitet fra Python. Fordelen med denne metoden er at den gir sømløs integrasjon mellom R og Python, inkludert deling av objekter mellom språkene. Dette gjør det enklere å kombinere styrkene fra begge miljøer i én arbeidsflyt. For å bruke reticulate, må pakken installeres i R:\nrenv::install(\"reticulate\")\nSe videoen under og koden reticulate_kjoring.R for eksempler.",
    "crumbs": [
      "Veiledning",
      "Integrering av R og Python"
    ]
  },
  {
    "objectID": "catalogue_edit.html",
    "href": "catalogue_edit.html",
    "title": "Dataeditering",
    "section": "",
    "text": "Dataeditering er kontroll, granskning og retting av data. Det omfatter editering av populasjon, editering av åpenbare og systematiske feil, seleksjon av verdier med stort avvik og høy innflytelse og kontroll av aggregater som skal bli publisert. Metodene som blir brukt til dataeditering spenner fra logisk kontroll av gyldig verdiområde til maskinlæring. All statistikk som publiseres er basert på data som har blitt kontrollert og i de fleste tilfeller også korrigert.\nDu kan finne mer information om dataediteringsprosess på Byrånettet.\n\n// Read in data\ntestdata = JSON.parse(my_ojs_data)\n\n\n\n\n\n\n\nviewof tema = Inputs.radio([\"kontrollere\", \"imputere\"],\n  {label: \"Metodeområde: \", value: \"kontrollere\"} \n)\n\nviewof metode = Inputs.radio(tema === \"imputere\" ? [\"donor\", \"modellbasert\"] : [\"regelbasert\", \"statistisk\"],\n{label: \"Metode: \", value: \"regelbasert\"}\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfiltered = testdata.filter(r =&gt; r.keyword.includes(metode) && r.keyword.includes(tema))\n\n\n\n\n\n\n\nfunction overflow_large(words) {\n  return (x) =&gt; htl.html`&lt;div style=\"\n    display: inline-block;\n    width: 450px;\n    white-space: pre-line;\n    break-text: auto;\n    overflow-wrap: normal;\n    height: auto;\n    word-wrap: break-word;\n    overflow: auto;\n\"&gt;${x.toLocaleString(\"en\")}`;\n}\n\n// Function for formatting names\nfunction overflow_names(words) {\n  return (x) =&gt; htl.html`&lt;div style=\"\n    display: inline-block;\n    width: 250px;\n    white-space: pre-line;\n    break-text: auto;\n    overflow-wrap: normal;\n    height: auto;\n    word-wrap: break-word;\n    overflow: auto;\n\"&gt;${x.toLocaleString(\"en\")}`;\n}\n\n// Function for adding hyperlinks\nfunction get_url(new_url) {\n  return (x) =&gt; htl.html`&lt;a href=${x.split(\";\")[1]} target=_blank&gt;${x.split(\";\")[0]} &lt;/a&gt;`;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nviewof filter_dt = Inputs.search(filtered)\n\ntable_out = Inputs.table(filter_dt, { columns: [\n    \"func_link\",\n    \"pack_link\",\n    \"språk\",\n    \"navn\",\n    \"description\"\n  ],\n  header: {\n    func_link: \"Funksjon\",\n    pack_link: \"Pakke\",\n    språk: \"Språk\",\n    navn: \"Navn\",\n    description: \"Beskrivelse\"\n  },\n  format: {\n  func_link: get_url(\n      filter_dt, \n      (d) =&gt; d[\"func_lnk\"]\n      ),\n  pack_link: get_url(\n      filter_dt, \n      (d) =&gt; d[\"pack_lnk\"]\n      ),\n  navn: overflow_names(\n  filter_dt,\n    (x) =&gt; x[\"navn\"]\n      ),\n  description: overflow_large(\n      filter_dt,\n      (x) =&gt; x[\"description\"]\n      ),\n  },\n  rows: 100\n})",
    "crumbs": [
      "Alle funksjoner",
      "Metodeområde",
      "Dataeditering"
    ]
  },
  {
    "objectID": "enhetstester.html",
    "href": "enhetstester.html",
    "title": "Hvordan å skrive enhetstester",
    "section": "",
    "text": "En enhetstest er en type programvaretesting hvor en liten del av kode blir individuelt og uavhengig undersøkt for riktighet. Dette er mest ofte brukt til å teste funksjoner.\nEn fordel med enhetstesting er at den gjør det mulig for utviklere å teste logikken i koden er riktig og at utfall er som forventet. Dermed kan det brukes til å identifisere feil på et tidlig stadium i utviklingsprosessen som kan spare tid og frustrasjoner i programvareutviklingsprosessen. Ved å bruke enhetstester kan utviklere også dokumentere koden og forstå hvordan den fungerer. Dette kan være spesielt nyttig når nye utviklere begynner å arbeide med koden, eller når funksjoner skal vedlikeholdes over tid. Det også gir en sikekrhet for når koden skal endres, at endringene ikke bryte eksisternede funksjonalitet.\n\n\n\n\n\n\nTipPlassering av enhetstester\n\n\n\nI Metodebiblioteket kjøres all enhetstester automatisk ved endring i repoen. For at dette skal fungere, må enhetstester i R ligge under mappen tests &gt; testthat og for Python skal de ligge under python &gt; tests.\n\n\n\nRPython\n\n\nImportere testthat pakken med\n\nrenv::install(\"testthat\")\n\nKoden under tester funksjonen add_floats()\n\nlibrary(testthat)\n\ntest_that(\"add_floats summere korrekt\", { \n  result &lt;- add_floats(2, 3) \n  expect_equal(result, 5) \n  result &lt;- add_floats(-1, 1) \n  expect_equal(result, 0) \n  })\n\nSe Eksempler på enhetstester i R (internt SSB) for mer detaljer.\n\n\nImporterer pakken pytest.\n\nimport pytest\n\nKoden under tester funksjonen is_prime ved bruk av assert.\n\nfrom pathlib import Path\n\nimport pandas as pd\nimport pytest\nfrom pandas import testing as tm\n\nfrom pytest_examples.functions import is_prime, valuta_omv\n\ndef test_is_prime():\n    assert is_prime(2) is True\n    assert is_prime(3) is True\n    assert is_prime(4) is False\n    assert is_prime(0) is False\n    assert is_prime(-5) is False\n\nSe Eksempler på bruk av pytest (internt SSB) for mer detaljer.\n\n\n\nFor generelle informasjon om enhetstest skriving se Hadley Wickhams veiledning til testthat for R eller veiledning til pytest for Python.\nDu finner mer informasjon om standard og anbefaling til enhetstester i SSB på KVAKK-sidene (internt SSB)",
    "crumbs": [
      "Veiledning",
      "Hvordan å skrive enhetstester"
    ]
  },
  {
    "objectID": "catalog.html",
    "href": "catalog.html",
    "title": "Katalog",
    "section": "",
    "text": "Her finner du en liste over alle funksjoner i Metodebiblioteket. Bruk alternativknappen for å filtrere funksjoner.\n\n// Read in data\ntestdata = JSON.parse(my_ojs_data)\n\n\n\n\n\n\n\nviewof lang = Inputs.radio(new Map([[\"ALLE\", \" \"], [\"R\", \"rfunc\"], [\"python\", \"python\"]]),\n  {label: \"Programmeringsspråk: \", value: \" \"}\n)\n\n\nviewof tema = Inputs.radio(new Map([[\"ALLE\", \" \"], [\"kontrollere\",\"kontrollere\"],\n[\"imputere\",\"imputere\"],\n[\"strukturere\",\"strukturere\"],\n[\"vekting og estimering\",\"vektberegning\"],\n[\"indeksberegning\",\"indeksberegning\"],\n[\"usikkerhetsberegning\",\"usikkerhetsberegning\"],\n[\"sesongjustering\",\"sesongjustering\"],\n[\"konfidensialitet\",\"konfidensialitet\"],\n[\"analyse\",\"analyse\"],\n[\"maskinlæring\", \"maskinlaering\"]]),\n  {label: \"Metodeområde: \", value: \" \"} \n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Filter data based on check boxes\n/*\nfiltered = testdata.filter(function(data) {\n  \n  return lang.every(r=&gt; data.keyword.includes(r)) &&\n    tema.every(r=&gt; data.keyword.includes(r))\n    ;\n})\n*/\n\nfiltered = testdata.filter(r =&gt; r.keyword.includes(lang) &&\n    r.keyword.includes(tema));\n\n\n\n\n\n\n\nfunction overflow_large(words) {\n  return (x) =&gt; htl.html`&lt;div style=\"\n    display: inline-block;\n    width: 450px;\n    white-space: pre-line;\n    break-text: auto;\n    overflow-wrap: normal;\n    height: auto;\n    word-wrap: break-word;\n    overflow: auto;\n\"&gt;${x.toLocaleString(\"en\")}`;\n}\n\n// Function for formatting names\nfunction overflow_names(words) {\n  return (x) =&gt; htl.html`&lt;div style=\"\n    display: inline-block;\n    width: 250px;\n    white-space: pre-line;\n    break-text: auto;\n    overflow-wrap: normal;\n    height: auto;\n    word-wrap: break-word;\n    overflow: auto;\n\"&gt;${x.toLocaleString(\"en\")}`;\n}\n\n// Function for adding hyperlinks\nfunction get_url(new_url) {\n  return (x) =&gt; htl.html`&lt;a href=${x.split(\";\")[1]} target=_blank&gt;${x.split(\";\")[0]} &lt;/a&gt;`;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nviewof filter_dt = Inputs.search(filtered)\n\ntable_out = Inputs.table(filter_dt, { columns: [\n    \"func_link\",\n    \"pack_link\",\n    \"navn\",\n    \"description\"\n  ],\n  header: {\n    func_link: \"Funksjon\",\n    pack_link: \"Pakke\",\n    navn: \"Navn\",\n    description: \"Beskrivelse\"\n  },\n  format: {\n  func_link: get_url(\n      filter_dt, \n      (d) =&gt; d[\"func_lnk\"]\n      ),\n  pack_link: get_url(\n      filter_dt,\n      (d) =&gt;d[\"pack_lnk\"]\n      ),\n  navn: overflow_names(\n  filter_dt,\n    (x) =&gt; x[\"navn\"]\n      ),\n  description: overflow_large(\n      filter_dt,\n      (x) =&gt; x[\"description\"]\n      ),\n  },\n  rows: 100\n})",
    "crumbs": [
      "Alle funksjoner",
      "Katalog"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Metodebiblioteket",
    "section": "",
    "text": "Metodebiblioteket er SSBs bibliotek for statistiske metode funksjoner. Metodene på liste er funksjoner skrevet i R eller python som passer i SSBs IT-platform. Alle funksjoner er testet av Seksjon for Metode for bruk i produksjon av offisielle statistikk. Alle er brukt i minst én produksjonsløp/eller brukt i SSBs interne metodekurs."
  },
  {
    "objectID": "prosess.html",
    "href": "prosess.html",
    "title": "Prosessmodell",
    "section": "",
    "text": "Når vi skal beskrive produksjonsprosessen for offisiell statistikk bruker vi FNs prosessmodell, Generic Statistical Business Process Model (GSBPM). Den beskriver og definerer prosessene som er nødvendige for å produsere offisiell statistikk.\nVi har samlet funksjoner i Metodebiblioteket etter prosessen de vanligvis benyttes i. Dette er kun ment som en hjelpemidle. Det er mulig at funksjonene kan benyttes i andre prosesser enn det som er beskrivet her.\n\n1 Avklare behov2 Planlegge3 Bygge4 Samle inn5 Klargjøre6 Analyse7 Formidle8 Evaluare\n\n\nIngen funksjoner enda.\n\n\nIngen funksjoner enda.\n\n\nIngen funksjoner enda.\n\n\nIngen funksjoner enda.\n\n\nVed klargjøring tenker vi mest ofte for dataediting men det inkludere også data integrering, klassifisering, beregning av vekter og aggregering. Her finner du funksjoner som kan benyttes i klargjørings steget\n\n5.1 Integrere Data5.2 Klassifisere og kode5.3 Kontrollere og validere5.4 Editere og imputere5.5 Avlede nye variabler5.6/5.7 Beregne vekter og aggregater5.8 Ferdigstille datafiler\n\n\nIngen funksjoner enda.\n\n\n\n\n\n\n\nFunksjon\nPakke\nNavn\nSpråk\nBeskrivelse\n\n\n\n\nCountVectorizer\nsklearn.feature_extraction.text\nCount vectorizer\nR\nConvert a collection of text documents to a matrix of token counts.\n\n\nSVC\nsklearn.svm\nC-Support Vector Classification.\nR\nThe implementation is based on libsvm. The fit time scales at least quadratically with the number of samples and may be impractical beyond tens of thousands of samples.\n\n\n\n\n\n\n\n\n\n\n\n\nFunksjon\nPakke\nNavn\nSpråk\nBeskrivelse\n\n\n\n\nAggrSml2NumVar\nKostra\nAggregated comparison of two numerical variables\nR\nCalculating aggregated values for two numerical variables, useful for comparison of the variables\n\n\nconfront\nvalidate\nConfront data with a (set of) expressionset(s)\nR\nAn expressionset is a general class storing rich expressions (basically expressions and some meta data) which we call 'rules'. Examples of expressionset implementations are 'validator' objects, storing validation rules and 'indicator' objects, storing data quality indicators. The 'confront' function evaluates the expressions one by one on a dataset while recording some process meta data. All results are stored in a (subclass of a) 'confrontation' object.\n\n\nDiff2NumVar\nKostra\nDifference between two numerical variables\nR\nCalculating the difference between two numerical variables Listing units with big difference, either the k units with the biggest absolute difference, or units with a absolute difference greater than a threshold Only units with value on both variables are used in the calculations\n\n\nget_extremes\nstruktuR\nGet extreme values Get extreme values in the sample dataset\nR\nGet extreme values Get extreme values in the sample dataset\n\n\nget_extremes\nstatstruk\nGet extremes\nR\nGet observations with extreme values based on their rstudized residual value or G value.\n\n\nHb\nKostra\nDetection of outliers using the Hidiroglou-Berthelot (HB) method\nR\nDetects possible outliers of a variable in period t by comparing it with revised values from period t-1\n\n\nOutlierRegressionMicro\nKostra\nFinding outliers of a sigle variable (y) by a regression model\nR\noutliers are found by using a limit for studentized residuals.\n\n\nQuartile\nKostra\nDetection of outliers using quartiles and by comparing with other\nR\nDetection of outliers using quartiles and by comparing with other data in same or previous period.\n\n\nRank2NumVar\nKostra\nComparing the biggest units with respect to two numerical\nR\nCalculating rank and share for two numerical variables, and the ratio between the variables Listing big units, either the k biggest units or units with value greater than a threshold\n\n\nThError\nKostra\nDetection of 1000-error\nR\nDetects units with possible 1000-error by comparing values in period t with revised values from period t-1\n\n\nvalidator\nvalidate\nDefine validation rules for data\nR\nDefine validation rules for data\n\n\n\n\n\n\n\n\n\n\n\n\nFunksjon\nPakke\nNavn\nSpråk\nBeskrivelse\n\n\n\n\nimpute_knn\nsimputation\nHot deck imputation\nR\nHot-deck imputation methods include random and sequential hot deck, k-nearest neighbours imputation and predictive mean matching.\n\n\nimpute_proxy\nsimputation\nImpute by variable derivation\nR\nImpute missing values by a constant, by copying another variable computing transformations from other variables.\n\n\nimpute_rhd\nsimputation\nHot deck imputation\nR\nHot-deck imputation methods include random and sequential hot deck, k-nearest neighbours imputation and predictive mean matching.\n\n\nlm\nstats\nFitting Linear Models\nR\n'lm' is used to fit linear models. It can be used to carry out regression, single stratum analysis of variance and analysis of covariance (although aov may provide a more convenient interface for these).\n\n\nLmImpute\nKostra\nINTERNAL FUNCTION: Regeression imputation.\nR\nImputation by weighted regeression, using lm, allowing multiple explanatory variables and multiple response variables. Impute missing and wrong values (category 3) by the model based on representative data (category 1). Some data are considered correct but not representative (category 2).\n\n\nmodifier\ndcmodify\nCreate or read a set of data modification rules\nR\nCreate or read a set of data modification rules\n\n\nOLS\nstatsmodels.regression.linear_model\nOrdinary Least Squares\nR\nConvert a collection of text documents to a matrix of token counts.\n\n\nSVC\nsklearn.svm\nC-Support Vector Classification.\nR\nThe implementation is based on libsvm. The fit time scales at least quadratically with the number of samples and may be impractical beyond tens of thousands of samples.\n\n\n\n\n\n\n\nIngen funksjoner enda\n\n\n\n\n\n\n\nFunksjon\nPakke\nNavn\nSpråk\nBeskrivelse\n\n\n\n\nCalcInd\nSSBpris\nCalculation of the estimate for a price index\nR\nCalculation of a price index\n\n\nCalcIndS2\nSSBpris\nCalculation of variance/sigma squared for price index\nR\nCalculation of sigma squared for a price index.\n\n\nCalibrateSSB\nCalibrateSSB\nCalibration weighting and estimation\nR\nCompute weights by calibration and corresponding estimates, totals and residuals\n\n\ne.calibrate\nReGenesees\nCalibration of Survey Weights\nR\nAdds to an 'analytic' object the calibrated weights column.\n\n\ne.svydesign\nReGenesees\nSpecification of a Complex Survey Design\nR\nBinds survey data and sampling design metadata.\n\n\nfill.template\nReGenesees\nFill the Known Totals Template for a Calibration Task\nR\nGiven a template prepared to store the totals of the auxiliary variables for a specific calibration task, computes the actual values of such totals from a sampling frame.\n\n\nget_estimates\nstatstruk\nGet Estimates\nR\nGet estimates for previously run model within strata or domains. Variance and CV estimates are returned for each domain.\n\n\nget_weights\nstatstruk\nGet weights\nR\nGet sample data with weights based on model.\n\n\nHierarchyCompute\nSSBtools\nHierarchical Computations\nR\nThis function computes aggregates by crossing several hierarchical specifications and factorial variables.\n\n\nlm\nstats\nFitting Linear Models\nR\n'lm' is used to fit linear models. It can be used to carry out regression, single stratum analysis of variance and analysis of covariance (although aov may provide a more convenient interface for these).\n\n\nmodel_aggregate\nSSBtools\nHierarchical aggregation via model specification\nR\nInternally a dummy/model matrix is created according to the model specification. This model matrix is used in the aggregation process via matrix multiplication and/or the function 'aggregate_multiple_fun'.\n\n\nOLS\nstatsmodels.regression.linear_model\nOrdinary Least Squares\nR\nConvert a collection of text documents to a matrix of token counts.\n\n\nPanelEstimation\nCalibrateSSB\nVariance estimation for panel data\nR\nVariance estimation of linear combinations of totals and ratios based on output from wideFromCalibrate\n\n\npop.template\nReGenesees\nTemplate Data Frame for Known Population Totals\nR\nConstructs a _\"template\"_ data frame to store known population totals for a calibration problem.\n\n\nquantile_weighted\nSSBtools\nWeighted quantiles\nR\nThe default method ('type=2') corresponds to weighted percentiles in SAS.\n\n\nratemodel\nstatstruk\nratemodel module\nR\nClass for estimating statistics for business surveys using a rate model.\n\n\nstruktur_model\nstruktuR\nRun a struktur model\nR\nEstimates total and uncertainty for a rate, homogeneous or regression model within strata.\n\n\nsvystatL\nReGenesees\nEstimation of Complex Estimators in Subpopulations\nR\nComputes estimates, standard errors and confidence intervals for Complex Estimators in subpopulations. A Complex Estimator can be any analytic function of (Horvitz-Thompson or Calibration) estimators of Totals and Means.\n\n\nsvystatTM\nReGenesees\nEstimation of Totals and Means in Subpopulations\nR\nComputes estimates, standard errors and confidence intervals for Totals and Means in subpopulations.\n\n\ntables_by_formulas\nSSBtools\nTabular Statistics Based on Formulas\nR\nThis function acts as an overlay for functions that produce tabular statistics through an interface utilizing the 'ModelMatrix()' function and its 'formula' parameter. Each table (individual statistic) is defined by a formula. The output is a single 'data.frame' that contains the results for all tables.\n\n\nweights\nReGenesees\nRetrieve Sampling Units Weights\nR\nExtracts the _current_ weights of units belonging to a survey design object.\n\n\n\n\n\n\n\nIngen funksjoner enda\n\n\n\n\n\n\n6.1 Utarbeid produktutkast6.2 Kvalitetssikre produkter6.3 Tolke og forklarer produkter6.4 Gjennomføre avslørings kontroll6.5 Ferdigstille produkter\n\n\n\n\n\n\n\nFunksjon\nPakke\nNavn\nSpråk\nBeskrivelse\n\n\n\n\nadd_constraint\nsadashboard\nAdd a constraint to a constraint data frame object and open for editing.\nR\nLegger til en opsjon(kolonne) i spesifikasjonsfil objektet og åpner det for redigering med R-pakken DataEditR\n\n\nedit_constraints\nsadashboard\nEdit a constraint data frame object.\nR\nFor redigering av celler spesifikasjonsfil objektet og åpner det for redigering med R-pakken DataEditR\n\n\nkonstruksjon\npickmdl\nLage faktorer for kalendereffekter\nR\nFleksibel funksjon som lager ulike kalendervariable, som f.eks. TD-, WD- og påskevariable, tilpasset norske forhold.\n\n\nmake_paramfile\nsadashboard\nCreate an initial parameter file where all values in a column are the same\nR\nOppretter en initial parameterfil der alle verdiene i en kolonne er de samme\n\n\nsa_quality_report\nsadashboard\nQuality Report for Seasonal Adjustment with RJDemetra\nR\nWrapper function for creating a html-document with interactive quality report for seasonal adjustment with RJdemetra. The quality report includes tables with selected quality indicators. User may also choose to include interactive plots of seasonally adjusted time series.\n\n\nx13\nRJDemetra\nSeasonal Adjustment with X13-ARIMA\nR\nFunctions to estimate the seasonally adjusted series (sa) with the X13-ARIMA method. This is achieved by decomposing the time series (y) into the trend-cycle (t), the seasonal component (s) and the irregular component (i). The final seasonally adjusted series shall be free of seasonal and calendar-related movements. x13 returns a preformatted result while jx13 returns the Java objects resulting from the seasonal adjustment.\n\n\nx13_automdl\npickmdl\nx13 with PICKMDL and partial concurrent possibilities\nR\nx13 can be run as usual (automdl) or with a PICKMDL specification. The ARIMA model, outliers and filters can be identified at a certain date and then held fixed (with a new outlier-span).\n\n\nx13_both\npickmdl\nx13_spec and x13_pickmdl wrapped as a single function\nR\nOutput is determined by the parameter: both_output.\n\n\nx13_pickmdl\npickmdl\nx13 with PICKMDL and partial concurrent possibilities\nR\nx13 can be run as usual (automdl) or with a PICKMDL specification. The ARIMA model, outliers and filters can be identified at a certain date and then held fixed (with a new outlier-span).\n\n\nx13_spec\nRJDemetra\nX-13ARIMA model specification, SA/X13\nR\nFunction to create (and/or modify) a c(\"SA_spec\", \"X13\") class object with the SA model specification for the X13 method. It can be done from a pre-defined \"JDemetra+\" model specification (a character), a previous specification (c(\"SA_spec\", \"X13\") object) or a seasonal adjustment model (c(\"SA\", \"X13\") object).\n\n\nx13_text_frame\npickmdl\nMultiple x13_both runs with code input from a data frame\nR\nGjør det mulig med sesongjustering av mange serier basert på parametere i en data.frame (f.eks lest inn fra en excel-fil).\n\n\n\n\n\n\n\nIngen funksjoner enda\n\n\nIngen funksjoner enda.\n\n\n\n\n\n\n\nFunksjon\nPakke\nNavn\nSpråk\nBeskrivelse\n\n\n\n\nGaussSuppressDec\nGaussSuppression\nCell suppression with synthetic decimal numbers\nR\n'GaussSuppressionFromData', or one of its wrappers, is run and decimal numbers are added to output by executing 'SuppressDec'.\n\n\nGaussSuppressionFromData\nGaussSuppression\nCell suppression from input data containing inner cells\nR\nAggregates are generated followed by primary suppression followed by secondary suppression by Gaussian elimination by 'GaussSuppression'\n\n\nPLSroundingPublish\nSmallCountRounding\nPLS inspired rounding\nR\nSmall count rounding of necessary inner cells are performed so that all small frequencies of cross-classifications to be published (publishable cells) are rounded. The publishable cells can be defined from a model formula, hierarchies or automatically from data.\n\n\nProtectKostra\nKostra\nTable suppression according to a frequency rule following the\nR\nTable suppression according to a frequency rule following the standards in the Kostra project.\n\n\nProtectTableData\neasySdcTable\nEasy interface to sdcTable: Table suppression according to a\nR\n'GaussSuppression', 'protectTable' or 'protect_linked_tables' is run with a data set as the only required input. One (stacked) or several (unstacked) input variables can hold cell counts. 'ProtectTableData' is a tidy wrapper function, which returns a single data frame instead of a list ('info' omitted).\n\n\nsdc_lonn\nsdclonn\nUndertrykking i lønnsstatistikk\nR\nInput er mikrodata og output er (samordnede) tabell(er) med alle ønskede aggregeringsnivåer.\n\n\nSdcForetakPerson\nSdcForetakPerson\nPrikking av foretak og avrunding eller prikking av personer\nR\nPrikking av foretak og avrunding eller prikking av personer. Sett parameteren 'allowTotal' til 'TRUE' for at kategorier innen ('within') foretak skal prikkes samtidig som totalverdier over disse grupperingene tillates publisert.\n\n\nSuppressDominantCells\nGaussSuppression\nSuppress magnitude tables using dominance (n,k) or p% rule for\nR\nThis function utilizes 'MagnitudeRule'.\n\n\nSuppressFewContributors\nGaussSuppression\nFew contributors suppression\nR\nThis function provides functionality for suppressing magnitude tables based on the few contributors rule ('NContributorsRule').\n\n\nSuppressionFromDecimals\nGaussSuppression\nCell suppression from synthetic decimal numbers\nR\nDecimal numbers, as calculated by 'GaussSuppressDec', are used to decide suppression (whole numbers or not). Technically, the calculations are done via 'GaussSuppressionFromData', but without running 'GaussSuppression'. All suppressed cells are primary suppressed.\n\n\nSuppressKDisclosure\nGaussSuppression\nK-disclosure suppression\nR\nA function for suppressing frequency tables using the k-disclosure method.\n\n\nSuppressLinkedTables\nGaussSuppression\nConsistent Suppression of Linked Tables\nR\nProvides alternatives to global protection for linked tables through methods that may reduce the computational burden.\n\n\nSuppressSmallCounts\nGaussSuppression\nSmall count frequency table suppression.\nR\nThis is a wrapper function of 'GaussSuppressionFromData' for small count frequency suppression. For common applications, the 'spec' parameter can be adjusted, see 'PackageSpecs' for more information. See Details for more information on function call customization.\n\n\n\n\n\n\n\nIngen funksjoner enda.\n\n\n\n\n\nIngen funksjoner enda\n\n\nIngen funksjoner enda",
    "crumbs": [
      "Alle funksjoner",
      "Processmodell"
    ]
  },
  {
    "objectID": "catalogue_conf.html",
    "href": "catalogue_conf.html",
    "title": "Konfidensialitet",
    "section": "",
    "text": "Statistikkloven § 7. Statistisk konfidensialitet ved formidling av offisiell statistikk pålegger at vi ikke publiserer statistikk slik at statistisk informasjon kan føres tilbake til enkeltpersoner eller andre typer statistiske enheter. Hvis dette likevel skjer sier vi at det har funnet sted en avsløring.\nHvis hensynet til oppbyggingen av statistikken krever det, kan det i noen tilfeller gjøres unntak. Slik publisering må ikke være til skade for de statistiske enhetene som inngår i statistikken.\nAt vi i SSB følger dette er avgjørende for oppgavegivernes tillit til oss og for at vi skal kunne utføre vårt samfunnsoppdrag.\n\n// Read in data\ntestdata = JSON.parse(my_ojs_data)\n\n\n\n\n\n\n\nviewof tema = Inputs.radio( [\"undertrykking\", \"avrunding\", \"støylegging\"],\n  {label: \"Metodeområde: \", value: \"undertrykking\"}\n)\n\n\n\n\n\n\n\n// Filter data based on check boxes\nfiltered = testdata.filter(r=&gt; r.keyword.includes(tema));\n\n\n\n\n\n\n\nfunction overflow_large(words) {\n  return (x) =&gt; htl.html`&lt;div style=\"\n    display: inline-block;\n    width: 450px;\n    white-space: pre-line;\n    break-text: auto;\n    overflow-wrap: normal;\n    height: auto;\n    word-wrap: break-word;\n    overflow: auto;\n\"&gt;${x.toLocaleString(\"en\")}`;\n}\n\n// Function for formatting names\nfunction overflow_names(words) {\n  return (x) =&gt; htl.html`&lt;div style=\"\n    display: inline-block;\n    width: 250px;\n    white-space: pre-line;\n    break-text: auto;\n    overflow-wrap: normal;\n    height: auto;\n    word-wrap: break-word;\n    overflow: auto;\n\"&gt;${x.toLocaleString(\"en\")}`;\n}\n\n// Function for adding hyperlinks\nfunction get_url(new_url) {\n  return (x) =&gt; htl.html`&lt;a href=${x.split(\";\")[1]} target=_blank&gt;${x.split(\";\")[0]} &lt;/a&gt;`;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nviewof filter_dt = Inputs.search(filtered)\n\ntable_out = Inputs.table(filter_dt, { columns: [\n    \"func_link\",\n    \"pack\",\n    \"språk\",\n    \"navn\",\n    \"description\"\n  ],\n  header: {\n    func_link: \"Funksjon\",\n    pack_link: \"Pakke\",\n    språk: \"Språk\",\n    navn: \"Navn\",\n    description: \"Beskrivelse\"\n  },\n  format: {\n  func_link: get_url(\n      filter_dt, \n      (d) =&gt; d[\"func_lnk\"]\n      ),\n  pack_link: get_url(\n      filter_dt, \n      (d) =&gt; d[\"pack_lnk\"]\n      ),\n  navn: overflow_names(\n  filter_dt,\n    (x) =&gt; x[\"navn\"]\n      ),\n  description: overflow_large(\n      filter_dt,\n      (x) =&gt; x[\"description\"]\n      ),\n  },\n  rows: 100\n})",
    "crumbs": [
      "Alle funksjoner",
      "Metodeområde",
      "Konfidensialitet"
    ]
  },
  {
    "objectID": "bidra.html",
    "href": "bidra.html",
    "title": "Bidra til Metodebiblioteket",
    "section": "",
    "text": "Har du brukt en metodiske funksjon som du mener kan være nyttig for andre i SSB? Da kan det vurderes for Metodebiblioteket. Selve kode for funksjonen skal ikke ligge i biblioteket siden dette er en metapakke. Den referere til andres pakker men samle en liste over nyttige metodiske funksjoner for offisiell statistikk.\nHer finner du veiledning om hvordan du kan bidra til Metodebiblioteket med en funksjon.\n\nClone repository og lage en ny branch: Clone repository fra github. Dette kan du gjøre fra terminalet eller fra RStudio for eksempel. Lage en ny branch for endringer.\nLegg funksjonen inn i create_table.R: Åpne filen som ligger under “internal” som heter “create_table.R”. Legg inn en ny rad med funksjonen “add_func()”. Skriv navn av funksjonen, pakkenavn og stikkord. Standard stikkord som skal brukkes ligger på Readme filen til repository. Skriv gjerne inn (GSBPM) prosessnummer i stikkord også.\nKjør add_func(): Kjør den nye raden du har skrevet som inkludere add_func(). Dette oppdatere datafil som ligger bak Metodebiblioteket.\nLegg pakken som brukes inn i DESCRIPTION fil: Hvis du har lagt inn en ny R funksjon skal pakken også ligge i DESCRIPTION filen under imports. Dette er for at Metodebiblioteket skal også fungere som en metapakke. Hvis pakken ligger der fra før er det ikke nødvendig å legge det inn på nytt.\nSkriv en enhetstest til funksjonen: For å forsikre kvalitet til funksjonene vi inkluderer i Metodebiblioteket har vi et mål at alle funksjoner skal har minst en enhetstest. Disse testene kjøres automatisk ved endring til hoved branch for å sjekke at funksjoner fungere som de skal. For mer informasjon om enhetstest se Hvordan å skrive enhetstester.\nCommit og push endringer til github: Commit og push endringer til github. Alle endringer til create_table.R filen, data filen (“katalogdata.csv”), hjelpefiler (DESCRIPTION og reexports.R), og enhetstester skal inkluderes. Til slutt, lage en pull request for å merge branch inn til main som da starter oppdatering av nettsiden automatisk.",
    "crumbs": [
      "Veiledning",
      "Bidra til Metodebiblioteket"
    ]
  },
  {
    "objectID": "catalogue_sesong.html",
    "href": "catalogue_sesong.html",
    "title": "Sesongjustering og tidsserieanalyse",
    "section": "",
    "text": "Sesongjustering er å bruke statistiske metoder for å fjerne systematiske sesongvariasjoner fra en månedlig eller kvartalsvis tidsserie, slik at tidsserien i størst mulig grad uttrykker den reelle utviklingen over tid. I tillegg forsøker man å fjerne kalendereffektene som varierer fra år til år, slik som påske. I sesongjusteringsprosessen spaltes den prekorrigerte (kalenderjusterte) tidsserien opp i tre komponenter: sesong, en irregulær og trend-syklus. Når dataene er korrigert for de sesongrelaterte forholdene, vil man stå igjen med et klarere bilde av den underliggende utviklingen i tidsserien som består av trend-syklus og irregulær komponent. Sesongjusterte data brukes ofte som utgangspunkt for opprettelse eller revidering av økonomisk politikk og økonomisk forskning på høyt nivå. Trend-syklus-komponenten er glattere enn sesongjusterte tall, og kan evt. formidles til brukerne i tillegg. I tidsserieanalyse kan en også justere tidsseriene for evt. brudd.\nDu kan finne mer informasjon om Sesongjustering og tidsserieanalyse på Byrånettet.",
    "crumbs": [
      "Alle funksjoner",
      "Metodeområde",
      "Sesongjustering og tidsserieanalyse"
    ]
  },
  {
    "objectID": "daplalab.html",
    "href": "daplalab.html",
    "title": "Bruk en funksjon i kode på Dapla Lab",
    "section": "",
    "text": "Om Dapla Lab\nDapla Lab er SSBs ny arbeidsbenk for statistikkproduksjon og forskning. Dapla Lab gir brukeren tilgang til ulike verktøy for utvikling og kjøring av produksjonsløp i SSB.\nFor å starte Dapla Lab, åpne en web-browser og navigere til https://lab.dapla.ssb.no/. Velge Logg inn øverst i høyre hjørne. Mer detaljer finner du i Dapla-manualen.\nAlle funksjoner i Metodebiblioteket kan brukes på Dapla Lab. Men:\n\nR funksjoner kan kjøres i Rstudio, Jupyter og VSCode miljøene.\nPython funksjoner kan forløpig kun kjøres på Jupyter og VSCode miljøene.\n\n\n\nInstallere Pakken\nMetodebiblioteket er bygd som en R-pakke og kan installeres for å få tilgang til alle R-funksjoner. I generelt, anbefaler vi istedenfor å installere kun de pakkene til funksjoner som skal faktisk brukes. Dette er for å unngå unødvendige avhengighter.\n\n\nIntegrering av Python og R\nMange funksjoner i Metodebiblioteket er skrevet i R. Disse kan fortsatt brukes, selv om du skriver produksjonsløpet i Python. Se siden om hvordan å integrere R og Python for mer detaljer.",
    "crumbs": [
      "Veiledning",
      "Bruk en funksjon i kode på Dapla Lab"
    ]
  },
  {
    "objectID": "status.html",
    "href": "status.html",
    "title": "Status på metodebiblioteket",
    "section": "",
    "text": "Denne siden inneholder informasjon om status på funksjoner i SSBs Metodebiblioteket. Den er status som er genererte 2025-07-23.",
    "crumbs": [
      "Status",
      "Status på metodebiblioteket"
    ]
  },
  {
    "objectID": "status.html#oversikt",
    "href": "status.html#oversikt",
    "title": "Status på metodebiblioteket",
    "section": "Oversikt",
    "text": "Oversikt\nDet er 59 funksjoner i Metodebiblioteket",
    "crumbs": [
      "Status",
      "Status på metodebiblioteket"
    ]
  },
  {
    "objectID": "status.html#nøkkelord",
    "href": "status.html#nøkkelord",
    "title": "Status på metodebiblioteket",
    "section": "Nøkkelord",
    "text": "Nøkkelord\nNøkkelord brukes til å organisere Metodebiblioteket. Følgende ord brukes i Metodebiblioteket. GSDPM steg nummer ikke inkluderes her.\n\n\n\n\n\nNokkelord\nAntall\n\n\n\n\nanalyse\n5\n\n\navrunding\n2\n\n\ndesignbasert\n2\n\n\ndonor\n3\n\n\nimputere\n8\n\n\nindeksberegning\n2\n\n\nkonfidensialitet\n12\n\n\nkontrollere\n12\n\n\nmaskinlaering\n2\n\n\nmodellbasert\n7\n\n\npython\n7\n\n\nregelbasert\n3\n\n\nrfunc\n52\n\n\nromlig\n2\n\n\nsesongjustering\n7\n\n\nstatistisk\n10\n\n\nstrukturere\n3\n\n\nundertrykking\n11\n\n\nusikkerhetsberegning\n4\n\n\nvektberegning\n15\n\n\n\n\n\n Følgende ord er nøkkelord knyttet til en funksjon men er ikke inn i standardlisten\n\n\n\n\n\nNokkelord:",
    "crumbs": [
      "Status",
      "Status på metodebiblioteket"
    ]
  },
  {
    "objectID": "status.html#enhetstester",
    "href": "status.html#enhetstester",
    "title": "Status på metodebiblioteket",
    "section": "Enhetstester",
    "text": "Enhetstester\nHver funksjon i Metodebiblioteket skal ha minst en enhetstest knyttet til den. Dette er for å forsikre kvalitet og kunne tester funksjoner på nye og gamle R installasjoner.\nFølgende tabellen viser hvilke funksjoner mangler enhetstester eller har enhetstester som feiler\n\n\n\n\n\nfunksjon_navn\nfunksjon_pakke\nfunksjon_spraak\nstatus\ndetaljer\n\n\n\n\nkonstruksjon\npickmdl\nrfunc\nmangler\n\n\n\nOLS\nstatsmodels.regression.linear_model\npython\nmangler\n\n\n\nx13\nRJDemetra\nrfunc\nmangler\n\n\n\nx13_automdl\npickmdl\nrfunc\nmangler\n\n\n\nx13_both\npickmdl\nrfunc\nmangler\n\n\n\nx13_pickmdl\npickmdl\nrfunc\nmangler\n\n\n\nx13_spec\nRJDemetra\nrfunc\nmangler\n\n\n\nx13_text_frame\npickmdl\nrfunc\nmangler",
    "crumbs": [
      "Status",
      "Status på metodebiblioteket"
    ]
  },
  {
    "objectID": "status.html#linker",
    "href": "status.html#linker",
    "title": "Status på metodebiblioteket",
    "section": "Linker",
    "text": "Linker\nMetodebiblioteket innholder mange linker til dokumentasjon av funksjoner. Følgende funksjoner har linker som feiler:\n\n\n\n\n\nfunksjon_navn\npakke",
    "crumbs": [
      "Status",
      "Status på metodebiblioteket"
    ]
  },
  {
    "objectID": "status.html#antall-som-bruker-funksjoner-på-github",
    "href": "status.html#antall-som-bruker-funksjoner-på-github",
    "title": "Status på metodebiblioteket",
    "section": "Antall som bruker funksjoner på GitHub",
    "text": "Antall som bruker funksjoner på GitHub\nFiguren under viser hvor mange bruker funksjoner i Metodebiblioteket basert på SSBs GitHUb. Vi har hentet data baserte på om funksjonen finnes i script-filene på repo som begynner med “stat-”. Status er per: 2025-07-23",
    "crumbs": [
      "Status",
      "Status på metodebiblioteket"
    ]
  },
  {
    "objectID": "catalogue_est.html",
    "href": "catalogue_est.html",
    "title": "Estimering og vekting",
    "section": "",
    "text": "Estimering er å finne verdi for en populasjonsstørrelse basert på den informasjonen vi har samlet inn fra (utvalgs)undersøkelsen. Vanligvis er vi interessert i forskjellige størrelser - totaler, gjennomsnitt, andeler og varianser er mest vanlig - for ulike variabler. Estimering innebærer ofte at hver enhet i utvalget tildeles en vekt, dette gjøres så godt som alltid for person- og husholdningsundersøkelser. Vi kan også basere estimeringen på en statistisk modell, noe som er vanlig å gjøre i næringslivsundersøkelser.\nDu kan finne mer information om estimering og vekting på Byrånettet.\n\n// Read in data\ntestdata = JSON.parse(my_ojs_data)\n\n\n\n\n\n\n\nviewof tema = Inputs.radio([\"vektberegning\", \"usikkerhetsberegning\"],\n  {label: \"Metodeområde: \", value: \"vektberegning\"} \n)\n\n\n\n\n\n\n\nfiltered = testdata.filter(r =&gt; r.keyword.includes(tema))\n\n\n\n\n\n\n\nfunction overflow_large(words) {\n  return (x) =&gt; htl.html`&lt;div style=\"\n    display: inline-block;\n    width: 450px;\n    white-space: pre-line;\n    break-text: auto;\n    overflow-wrap: normal;\n    height: auto;\n    word-wrap: break-word;\n    overflow: auto;\n\"&gt;${x.toLocaleString(\"en\")}`;\n}\n\n// Function for formatting names\nfunction overflow_names(words) {\n  return (x) =&gt; htl.html`&lt;div style=\"\n    display: inline-block;\n    width: 250px;\n    white-space: pre-line;\n    break-text: auto;\n    overflow-wrap: normal;\n    height: auto;\n    word-wrap: break-word;\n    overflow: auto;\n\"&gt;${x.toLocaleString(\"en\")}`;\n}\n\n// Function for adding hyperlinks\nfunction get_url(new_url) {\n  return (x) =&gt; htl.html`&lt;a href=${x.split(\";\")[1]} target=_blank&gt;${x.split(\";\")[0]} &lt;/a&gt;`;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nviewof filter_dt = Inputs.search(filtered)\n\ntable_out = Inputs.table(filter_dt, { columns: [\n    \"func_link\",\n    \"pack_link\",\n    \"språk\",\n    \"navn\",\n    \"description\"\n  ],\n  header: {\n    func_link: \"Funksjon\",\n    pack_link: \"Pakke\",\n    språk: \"Språk\",\n    navn: \"Navn\",\n    description: \"Beskrivelse\"\n  },\n  format: {\n  func_link: get_url(\n      filter_dt, \n      (d) =&gt; d[\"func_lnk\"]\n      ),\n  pack_link: get_url(\n      filter_dt, \n      (d) =&gt; d[\"pack_lnk\"]\n      ),\n  navn: overflow_names(\n  filter_dt,\n    (x) =&gt; x[\"navn\"]\n      ),\n  description: overflow_large(\n      filter_dt,\n      (x) =&gt; x[\"description\"]\n      ),\n  },\n  rows: 100\n})",
    "crumbs": [
      "Alle funksjoner",
      "Metodeområde",
      "Estimering og vekting"
    ]
  }
]